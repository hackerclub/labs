#!/bin/bash

# this perl expression fills up the buffer and padding which comes afterward. It then
# places the address of bar(), accounting for little endian, into the return address
# foo will use to exit.

./buf $(perl -e 'print "A"x32 . "\x74\x84\x04\x08"')

# if we look at gdb we can determine why the segfault at the end occurs. first, it's
# important to know that the old ebp is stored on the stack above the old eip, or return
# address. [ eip: instruction pointer or PC, ebp: base pointer, stores the old stack
# frame address ].

# we overwrite the old ebp with 0x41414141. When foo exits or begins executing the 
# function epilogue it executes the 'leave' instruction. the 'leave' instruction 
# is a macro which translates into 'mov esp, ebp; pop ebp;'. In essences it makes the
# bottom of the current frame the new top of the stack, and it grabs the location of
# the new stack frame from the top of the stack.

# bar() now thinks 0x41414141 is the bottom of it's stack frame. However this will
# quickly become irrelevant when bar() executes 'mov ebp, esp'. What actually screws
# up bar() is that it will try to return to the location right below our overwritten 
# pointer, because it will treat the word underneath the overwritten return
# address as our new stacktop when it begin executing bar().
